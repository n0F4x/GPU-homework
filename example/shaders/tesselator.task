#version 450

#extension GL_EXT_mesh_shader: require
#extension GL_EXT_buffer_reference: require
#extension GL_GOOGLE_include_directive: require

#include "shared.glsl"


layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;


struct Camera {
    vec4 position;
    mat4 view;
    mat4 projection;
};
layout (set = 0, binding = 0) uniform Scene {
    Camera camera;
};

struct Vertex {
    vec2 position;
    vec2 texCoord;
};
layout (std430, buffer_reference, buffer_reference_align = 16) readonly buffer VertexBuffer {
    Vertex vertices[];
};
layout (set = 0, binding = 1) uniform Vertices {
    VertexBuffer vertexBuffer;
};


taskPayloadSharedEXT SharedData sharedData;


bool insideFrustum(vec3 position) {
    return !(
    position.x < -1.0 || position.x > 1.0 ||
    position.y < -1.0 || position.y > 1.0 ||
    position.z < -1.0 || position.z > 1.0
    );
}


void main() {
    if (gl_WorkGroupID.x == gl_NumWorkGroups.x - 1 || gl_WorkGroupID.y == gl_NumWorkGroups.y - 1) {
        return;
    }

    sharedData.vertexIndex = gl_WorkGroupID.y * gl_NumWorkGroups.y + gl_WorkGroupID.x;
    sharedData.vertexIndexX = (gl_WorkGroupID.y + 1) * gl_NumWorkGroups.y + gl_WorkGroupID.x;
    sharedData.vertexIndexY = gl_WorkGroupID.y * gl_NumWorkGroups.y + gl_WorkGroupID.x + 1;

    // Frustum cull
    {
        vec2 localPosition = vertexBuffer.vertices[sharedData.vertexIndex].position;
        vec3 worldPosition = vec3(localPosition.x, 0, localPosition.y);
        vec3 position = vec4(camera.projection * camera.view * vec4(worldPosition, 1)).xyz;

        vec2 localPositionX = vertexBuffer.vertices[sharedData.vertexIndexX].position;
        vec3 worldPositionX = vec3(localPositionX.x, 0, localPositionX.y);
        vec3 positionX = vec4(camera.projection * camera.view * vec4(worldPositionX, 1)).xyz;

        vec2 localPositionY = vertexBuffer.vertices[sharedData.vertexIndexY].position;
        vec3 worldPositionY = vec3(localPositionY.x, 0, localPositionY.y);
        vec3 positionY = vec4(camera.projection * camera.view * vec4(worldPositionY, 1)).xyz;

        vec3 positionXY = positionX + positionY - position;

        if (!insideFrustum(position) && !insideFrustum(positionX) && !insideFrustum(positionY) && !insideFrustum(positionXY)) {
            return;
        }
    }

    EmitMeshTasksEXT(1, 1, 1);
}
